Audio asset I/O
$Id$


This document specifies more clearly the actual handling of files by the
asset manager for audio assets. The goal of the asset manager is to free the
application from having to manage files and concentrate on assets.


1. Virtual edits and sequential media

1.1 Audio clips

The audio clip is the minimal component that we define. A clip describes a
continuous chunk of audio contained in a physical file. Audio assets are
made of audio clips, all of which share the same format (bit depth, sample
rate, channels, etc.) so there is no need to keep that information. A clip
is defined by three parameters:

  * the path of the physical file
  * the begin time of the clip
  * the end time of the clip

1.2 Audio assets

An audio asset is a collection of clips, all of which have the same formats.
To the application, an audio asset will look like a single unit, and behave
like one. An audio asset is defined by three parameters:

  * a text label
  * an audio format
  * a list of clips

1.3 Changes from milestone 1

1.3.1 Changes to IMediaAsset

* Path is removed because a media asset is not necessarily a single file.
* file is removed for the same reason.

1.3.2 Changes to IAudioMediaAsset

* AudioLengthBytes is changed to AudioLengthInBytes for consistency.

Of course, now that a media asset is a collection of clips, methods such as
LengthInMilliseconds and AudioLengthInBytes should return the total length
of the asset, that is the sum of the lengths of the clips.

1.3.3 Changes to IAudioPlayer

The interface to IAudioPlayer can be rethought a bit to make it more
consistent with IAudioMediaAsset. This concerns the Play() methods:

* void Play(IAudioMediaAsset asset) plays the asset
* void Play(IAudioMediaAsset asset, long begin, long end) plays from begin
byte position to end byte position
* void Play(IAudioMediaAsset asset, double begin, double end) plays from
begin time to end time (in milliseconds.)


2 Creating an asset

2.1 Creating a new asset from scratch

The new asset is created from a given set of parameters. No audio data will
exist at this point and the list of clips is empty. Presumably, new assets
will be created by the application once the user has selected parameters for
audio recording so all parameters are known.

Here is a proposed constructor for AudioMediaAsset:

* AudioMediaAsset(int channels, int bitDepth, int sampleRate)

I think the frame size can be determined automatically from these
parameters?

2.2 Creating a new asset from a Sequential object

The Urakawa toolkit defines the Sequential Media object, which is what the
assets will be mapped to (i.e., audio objects in the core tree will be
sequential media objects.) The list passed as argument is a list of Clip
objects. The first clip's file will give the parameters for the asset, and
the files for the other clips must have the same paramters. The audio data
for the asset is read from the files pointed to by every clip in the list.

* AudioMediaAsset(ArrayList clips)

2.3 Adding assets to the project

The assets are created through the asset manager; so the asset manager will
have methods to add new clips from scratch or from existing data.


3 Inserting and deleting audio in an asset

3.1 Inserting data from live recording

3.2 Inserting data from another asset

3.3 Deleting data from an asset


4 Merging, splitting and phrase detection

4.1 Merging two assets

4.2 Splitting an asset

4.3 Applying phrase detection to an asset


5 Saving and deleting assets

5.1 Saving an asset

5.2 Deleting an asset


6 Undo and Redo

The asset manager keeps track of all assets, but separates between "loved"
and "unloved" assets. Loved assets are the ones that are active in the
project; unloved assets are those that are kept so that changes can be
undone.
