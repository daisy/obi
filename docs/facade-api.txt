Obi façade API for iteration 2
$Id$


This new version of the facade is more a reaction to the current state of
the design and its implementation and how the application would like to see
it. This is still very sketchy but provides a starting point (and a laundry
list) for discussion. Order is not important but numbers allow to refer to
some points more easily.


1. Currently, the asset manager uses double for time whereas the toolkit
uses long. We need to make them agree.


2. Have a hash function for nodes that returns an unique value.


3. Have a method that returns a single channel given a name, a null value if
there is no channel with that name, and throw an exception if there is more
than one channel with that name (or return a null value.) This makes channel
management more enjoyable if we want only one channel with a given name at
any time.


4. More specfically, have a method that returns the media object for a node
set on a channel given its name. We probably need a mechanism for tying
media types to channels.


5. Allow empty strings (not null, but with a length of zero) for TextMedia.


6. Use delegates for visitor. I am using the C# terminology here, so it
should be formalized in the design by more neutral terminology. I propose
the following methods:

  IVisitableNode.VisitDepthFirst(delegate bool previsit(ICoreNode node));
  IVisitableNode.VisitDepthFirst(delegate bool previsit(ICoreNode node),
                                   delegate void postvisit(ICoreNode node));

This is so much more practical than creating a new class everytime we need a
slightly different visitor, especially when we need intimate access to the
current class (which can be solved by having the class itself implement
ICoreNodeVisitor, but it is a bit kludgy and works only once.)

Also, in my experience so far, there are many cases where only a previsitor
is necessary. We may even be able to specify

  IVisitableNode.VisitDepthFirst(delegate void postvisit(ICoreNode node));

if necessary. In the same way we could have VisitBreadthFirst() methods.

BTW, I am not necessarily saying the we should get rid of the visitor
interface, but in many cases I would rather use the delegates than a visitor
class.


7. Have metadata be accessible as a hash, with the name of the metadata
property as key, and a list of values as value (we may have several metadata
tags with the same name, e.g. several authors.)


8. Allow extra attributes for metadata (e.g. "role", see DC metadata for
DAISY 3.)


9. Have the C# toolkit use C# features: properties, generic classes (e.g.
node lists would be List<CoreNode> instead of ArrayList), delegates (see
visitors), etc.


10. Allow to change the NodeFactory of a presentation. I want to subclass
CoreNode, but not Presentation.


11. Project.openXUK() should return a meaningful error message when failing
to read in a XUK file.


12. Commands: so far in the application, we only create a new command if its
action was succesful, so we do not need predicates to test whether we can
undo or redo a method. The invariant of the command manager is that when a
command is undone, we go back to a state where redoing must succeed just
like it did when we issued the command. Same for redo.

---

13. Custom property factories: the new scheme for creating properties with
local name/namespace is better, but it may be hard to mix the usage of
several factories within an application, as they have to follow an
inheritance pattern. Maybe we could associate a factory with a namespace and
dispatch property creation based on a namespace? An application could then
have several factories that would not need to know about each other.


14. There is no function to get the previous and next sibling of a node.


15. MG: Toolkit factories should provide the facility of ascertaining required
properties on the factory before calling create(), or, when a certain attribute
of the returned object is required, provide a (non-overloaded) create() method 
that takes the required attribute as params. This makes the use less errorprone, 
and the usage code less verbose.

16. MD: Functions to move a section node: Up, Down, In, Out.  

17. MD: Clipboard feature 

18. MD: For 16, 17: adjustments are made automatically wrt DTBOOK (adjust heading levels, page numbers)


---


19. I would like to get the position of a node relative to its sibling
directly without having to call getParent().indexOf(), for instance
node.position(). Reason: getParent() returns a basic tree node, which
doesn't know about the indices of its positions...

20. Do we really need the supertypes of CoreNode? And the interfaces? (See
above.)
